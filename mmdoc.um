
import "std.um"

//~~Record
// Struct holding one documentation item.
type Record* = struct {
	line: int
	name: str
	docs: str
	content: str
}
//~~

//~~ Configuration variables
var (
	commentPrefix: str = "//"
	beginMark: str = "~~"
	endMark: str = "~~"
	url: str = ""
	lang: str = ""
)
//~~

//~~fn toMd
// Converts a record to markdown.
fn (this: ^Record) toMd(): str {
//~~
	name := this.name
	if url != "" {
		name = sprintf("[%s]("+url+")", name, this.line)
	}
	return sprintf(
		"## %s\n\n" +
		"```%s\n%s```\n\n" +
		"%s\n", name, lang, this.content, this.docs)
}

fn (this: ^Record) toHtml(): str {
	name := this.name
	if url != "" {
		name = sprintf("<a href=\"" + url + "\">%s</a>", this.line, name)
	}
	return sprintf(
		"<h2>%s</h2>\n\n" +
		"<code><pre>%s</pre></code>\n" +
		"<p>%s</p>\n", name, this.content, this.docs)
}

fn readall(f: std.File): str {
    const blockSize = 16
    res := ""

    for ok := true; ok {
	    var buff: [blockSize + 1]char
	    ok = std.fread(f, ^[blockSize]char(&buff)) == 1
	    res += str([]char(buff))
    }

    return res
}

fn hasPrefix(s, p: str, i: int): bool {
	if len(s) - i < len(p) { return false }

	for j:=0; j < len(p); j++ {
		if s[i] != p[j] { return false }
		i++
	}

	return true
}

fn split*(s, p: str): []str {
	o := []str{}
	e := 0

	for i:=0; i < len(s); i++ {
		if hasPrefix(s, p, i) {
			o = append(o, slice(s, e, i))
			i += len(p)
			e = i
		}
	}

	o = append(o, slice(s, e))

	return o
}

fn getRecord(lines: []str, i: ^int): Record {
	rec := Record{}

	dstart := i^
	dend := 0
	cend := 0
	const (
		phdocs = 0
		phcontent
	)
	ph := phdocs

	i^++
	for _:=0; i^ < len(lines); i^++ {
		ln := std.trim(lines[i^])

		if ph == phdocs && !hasPrefix(ln, commentPrefix, 0) {
			dend = i^
			ph = phcontent
		}

		if hasPrefix(ln, commentPrefix + endMark, 0) {
			cend = i^
			break
		}
	}

	n := slice(std.trim(lines[dstart]), len(commentPrefix + beginMark))

	if dend == 0 { dend = i^ }
	if cend == 0 { cend = dend }

	da := slice(lines, dstart + 1, dend)
	d := ""
	for j in da {
		d += std.trim(slice(da[j], 2)) + "\n"
	}

	ca := slice(lines, dend, cend)
	c := ""
	for j in ca {
		c += ca[j] + "\n"
	}

	return Record{ dend, n, d, c }
}

fn getRecords(lines: []str): []Record {
	recs := []Record{}

	for i:=0; i < len(lines); i++ {
		ln := std.trim(lines[i])
		if !hasPrefix(ln, commentPrefix + beginMark, 0) { continue }

		recs = append(recs, getRecord(lines, &i))
	}

	return recs
}

fn help() {
	printf("%s\n", "mmdoc - universal documentation utility\n" +
		"usage: mmdoc [ options ] file\n" +
		"\t-b <begin> (defaults to ~~)\n" +
		"\t-e <end pattern> (defaults to ~~)\n" +
		"\t-c <comment prefix> (defaults to //)\n" +
		"\t-u <file url> (%d is substituted to line number)\n" +
		"\t-l <lang-name> (defaults to \"\")\n" +
		"\t-h - export to html\n" +
		"\t-s - export to standalone html\n\n" +
		"Example:\n" +
		"\t//~~my_function\n" +
		"\t// Description of my function\n" +
		"\tvoid my_function() {\n" +
		"\t//~~")
}

fn main() {
	const (
		markdown = 0
		html
		htmlStandalone
	)

	exportType := markdown

	argc := std.argc()
	arg := 1
	for _:=0; arg < argc; arg++ {
		a := std.argv(arg)
		if len(a) != 2 || a[0] != '-' { break }
		if arg >= argc - 1 { help(); return }

		switch a[1] {
		case 'b':
			arg++
			beginMark = std.argv(arg)
		case 'e':
			arg++
			endMark = std.argv(arg)
		case 'c':
			arg++
			commentPrefix = std.argv(arg)
		case 'u':
			arg++
			url = std.argv(arg)
		case 'h':
			exportType = html
		case 's':
			exportType = htmlStandalone
		case 'l':
			arg++
			lang = std.argv(arg)
		default:
			help()
			return
		}
	}

	if arg >= argc { help(); return }

	f := std.fopen(std.argv(arg), "r")
	recs := getRecords(split(readall(f), "\n"))
	std.fclose(f)

	for i in recs {
		switch exportType {
		case markdown:
			printf("%s\n", recs[i].toMd())
		case html:
			printf("%s\n", recs[i].toHtml())
		case htmlStandalone:
			printf("<!DOCTYPE html><html lang=\"en\">\n" +
				"<head><meta charset=\"utf8\"></head>\n" +
				"<body>\n")
			printf("%s\n", recs[i].toHtml())
			printf("</body></html>")
		}
	}
}
