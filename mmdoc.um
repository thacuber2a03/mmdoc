
import "std.um"

//~~Record
// Struct holding one documentation item.
type Record* = struct {
	line: int
	name: str
	docs: str
	content: str
}
//~~

//~~Configuration variables
var (
	commentPrefix: str = "//"
	beginMark: str = "~~"
	endMark: str = "~~"
	url: str = ""
	lang: str = ""
)
//~~

//~~fn toMd
// Converts a record to markdown.
fn (this: ^Record) toMd(): str {
//~~
	name := this.name
	if url != "" {
		name = sprintf("[%s]("+url+")", name, this.line)
	}
	return sprintf(
		"## %s\n\n" +
		"```%s\n%s```\n\n" +
		"%s\n", name, lang, this.content, this.docs)
}

fn (this: ^Record) toHtml(): str {
	name := this.name
	if url != "" {
		name = sprintf("<a href=\"" + url + "\">%s</a>", this.line, name)
	}
	return sprintf(
		"<h2>%s</h2>\n\n" +
		"<code><pre>%s</pre></code>\n" +
		"<p>%s</p>\n", name, this.content, this.docs)
}

fn (this: ^Record) toTerm(): str {
	return sprintf(
		"\x1b[1m%s\x1b[0m\n\n" +
		"\x1b[3m%s\x1b[0m\n" +
		"%s\n---------\n", this.name, this.content, this.docs
	)
}

fn hasPrefix(s, p: str, i: int): bool {
	if len(s) - i < len(p) { return false }

	for j:=0; j < len(p); j++ {
		if s[i] != p[j] { return false }
		i++
	}

	return true
}

fn split*(s, p: str): []str {
	o := []str{}
	e := 0

	for i:=0; i < len(s); i++ {
		if hasPrefix(s, p, i) {
			o = append(o, slice(s, e, i))
			i += len(p)-1
			e = i+1
		}
	}

	o = append(o, slice(s, e))
	return o
}

fn getRecord(lines: []str, i: ^int): Record {
	rec := Record{}

	dstart := i^
	dend := 0
	cend := 0
	const (
		phdocs = 0
		phcontent
	)
	ph := phdocs

	i^++
	for _:=0; i^ < len(lines); i^++ {
		ln := std::trim(lines[i^])

		if ph == phdocs && !hasPrefix(ln, commentPrefix, 0) {
			dend = i^
			ph = phcontent
		}

		if hasPrefix(ln, commentPrefix + endMark, 0) {
			cend = i^
			break
		}
	}

	n := slice(std::trim(lines[dstart]), len(commentPrefix + beginMark))

	if dend == 0 { dend = i^ }
	if cend == 0 { cend = dend }

	da := slice(lines, dstart + 1, dend)
	d := ""
	for j in da {
		d += std::trim(slice(da[j], 2)) + "\n"
	}

	ca := slice(lines, dend, cend)
	c := ""
	for j in ca {
		c += ca[j] + "\n"
	}

	return Record{ dend+1, n, d, c }
}

fn getRecords(lines: []str): []Record {
	recs := []Record{}

	for i:=0; i < len(lines); i++ {
		ln := std::trim(lines[i])
		if !hasPrefix(ln, commentPrefix + beginMark, 0) { continue }

		recs = append(recs, getRecord(lines, &i))
	}

	return recs
}

fn help() {
	printf("%s\n", "mmdoc - universal documentation utility\n" +
		"usage: mmdoc [ options ] file\n" +
		"\t-b <begin> (defaults to ~~)\n" +
		"\t-e <end pattern> (defaults to ~~)\n" +
		"\t-c <comment prefix> (defaults to //)\n" +
		"\t-u <file url> (%d is substituted to line number)\n" +
		"\t-l <lang-name> (defaults to \"\")\n" +
		"\t-h - export to html\n" +
		"\t-s - export to standalone html\n\n" +
		"\t-t - export to terminal\n\n" +
		"Example:\n" +
		"\t//~~my_function\n" +
		"\t// Description of my function\n" +
		"\tvoid my_function() {\n" +
		"\t//~~")
}

fn main() {
	const (
		markdown = 0
		html
		htmlStandalone
		term
	)

	exportType := markdown

	argc := std::argc()
	arg := 1
	for _:=0; arg < argc; arg++ {
		a := std::argv(arg)
		if len(a) != 2 || a[0] != '-' { break }
		if arg >= argc - 1 { help(); return }

		switch a[1] {
		case 'b':
			arg++
			beginMark = std::argv(arg)
		case 'e':
			arg++
			endMark = std::argv(arg)
		case 'c':
			arg++
			commentPrefix = std::argv(arg)
		case 'u':
			arg++
			url = std::argv(arg)
		case 'h':
			exportType = html
		case 's':
			exportType = htmlStandalone
		case 't':
			exportType = term
		case 'l':
			arg++
			lang = std::argv(arg)
		default:
			help()
			return
		}
	}

	if arg >= argc { help(); return }

	f, err := std::fopen(std::argv(arg), "rb")
	std::exitif(err)

	data, err := std::freadall(f)
	std::exitif(err)
	recs := getRecords(split(str(data), "\n"))

	err = std::fclose(f)
	std::exitif(err)

	for i in recs {
		switch exportType {
		case markdown:
			printf("%s\n", recs[i].toMd())
		case html:
			printf("%s\n", recs[i].toHtml())
		case term:
			printf("%s\n", recs[i].toTerm())
		case htmlStandalone:
			printf("<!DOCTYPE html><html lang=\"en\">\n" +
				"<head><meta charset=\"utf8\"></head>\n" +
				"<body>\n")
			printf("%s\n", recs[i].toHtml())
			printf("</body></html>")
		}
	}
}
